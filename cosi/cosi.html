<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Collective Edwards-Curve Digital Signature Algorithm</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Scope"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Notations and Conventions"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Collective Signing"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Collective Public Key Setup"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Signature Generation"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Signature Verification"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Collective Signing Protocol"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Collective Signature"/>
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Announcement"/>
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Commitment"/>
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 Challenge"/>
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 Response"/>
<link href="#rfc.section.5.1.5" rel="Chapter" title="5.1.5 Signature Generation"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Collective Verification"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Tree-based CoSi Protocol"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 CoSi Tree"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Collective Signature"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 Announcement"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 Commitment"/>
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 Challenge"/>
<link href="#rfc.section.6.2.4" rel="Chapter" title="6.2.4 Response"/>
<link href="#rfc.section.6.2.5" rel="Chapter" title="6.2.5 Signature Generation"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Verification"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Message Format"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Announcement"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Commitment"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Challenge"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Response"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 General Implementations Checks"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Random Number Generation"/>
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Group Membership"/>
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Multiplication by Cofactor in Verification"/>
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Related-Key Attacks"/>
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 Availability"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Discussions"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Hashing the Public Keys in the commitment"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Hashing the bitmask in the commitment"/>
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Exception Mechanism"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Ford, B., Gailly, N., Gasser, L., and P. Jovanovic" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ford-cfrg-cosi-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-7-5" />
  <meta name="dct.abstract" content="Collective signatures are compact cryptographic proofs showing that several distinct secret key holders, called cosigners, have cooperated to sign a given message. This document describes a collective signature extension to the EdDSA signing schemes for the Ed25519 and Ed448 elliptic curves. A collective EdDSA signature consists of a point R, a scalar s, and a bitmask Z indicating the specific subset of a known group of cosigners that produced this signature. A collective signature produced by n cosigners is of size 64+ceil(n/8) bytes for Ed25519 and 114+ceil(n/8) bytes for Ed448, respectively, instead of 64n and 114n bytes for n individual signatures. Further, collective signature verification requires only one double scalar multiplication rather than n. The verifier learns exactly which subset of the cosigners participated, enabling the verifier to implement flexible acceptance-threshold policies, and preserving transparency and accountability in the event a bad message is collectively signed.  " />
  <meta name="description" content="Collective signatures are compact cryptographic proofs showing that several distinct secret key holders, called cosigners, have cooperated to sign a given message. This document describes a collective signature extension to the EdDSA signing schemes for the Ed25519 and Ed448 elliptic curves. A collective EdDSA signature consists of a point R, a scalar s, and a bitmask Z indicating the specific subset of a known group of cosigners that produced this signature. A collective signature produced by n cosigners is of size 64+ceil(n/8) bytes for Ed25519 and 114+ceil(n/8) bytes for Ed448, respectively, instead of 64n and 114n bytes for n individual signatures. Further, collective signature verification requires only one double scalar multiplication rather than n. The verifier learns exactly which subset of the cosigners participated, enabling the verifier to implement flexible acceptance-threshold policies, and preserving transparency and accountability in the event a bad message is collectively signed.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">CFRG</td>
  <td class="right">B. Ford</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">N. Gailly</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">L. Gasser</td>
</tr>
<tr>
  <td class="left">Expires: January 6, 2018</td>
  <td class="right">P. Jovanovic</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">EPFL</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">July 5, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Collective Edwards-Curve Digital Signature Algorithm<br />
  <span class="filename">draft-ford-cfrg-cosi-00</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>Collective signatures are compact cryptographic proofs showing that several distinct secret key holders, called cosigners, have cooperated to sign a given message. This document describes a collective signature extension to the EdDSA signing schemes for the Ed25519 and Ed448 elliptic curves. A collective EdDSA signature consists of a point R, a scalar s, and a bitmask Z indicating the specific subset of a known group of cosigners that produced this signature. A collective signature produced by n cosigners is of size 64+ceil(n/8) bytes for Ed25519 and 114+ceil(n/8) bytes for Ed448, respectively, instead of 64n and 114n bytes for n individual signatures. Further, collective signature verification requires only one double scalar multiplication rather than n. The verifier learns exactly which subset of the cosigners participated, enabling the verifier to implement flexible acceptance-threshold policies, and preserving transparency and accountability in the event a bad message is collectively signed.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 6, 2018.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Scope</a></li>
<li>3.   <a href="#rfc.section.3">Notations and Conventions</a></li>
<li>4.   <a href="#rfc.section.4">Collective Signing</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Collective Public Key Setup</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Signature Generation</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Signature Verification</a></li>
</ul><li>5.   <a href="#rfc.section.5">Collective Signing Protocol</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Collective Signature</a></li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Announcement</a></li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Commitment</a></li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">Challenge</a></li>
<li>5.1.4.   <a href="#rfc.section.5.1.4">Response</a></li>
<li>5.1.5.   <a href="#rfc.section.5.1.5">Signature Generation</a></li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Collective Verification</a></li>
</ul><li>6.   <a href="#rfc.section.6">Tree-based CoSi Protocol</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">CoSi Tree</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Collective Signature</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">Announcement</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">Commitment</a></li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">Challenge</a></li>
<li>6.2.4.   <a href="#rfc.section.6.2.4">Response</a></li>
<li>6.2.5.   <a href="#rfc.section.6.2.5">Signature Generation</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Verification</a></li>
</ul><li>7.   <a href="#rfc.section.7">Message Format</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Announcement</a></li>
<li>7.2.   <a href="#rfc.section.7.2">Commitment</a></li>
<li>7.3.   <a href="#rfc.section.7.3">Challenge</a></li>
<li>7.4.   <a href="#rfc.section.7.4">Response</a></li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">General Implementations Checks</a></li>
<li>8.2.   <a href="#rfc.section.8.2">Random Number Generation</a></li>
<li>8.3.   <a href="#rfc.section.8.3">Group Membership</a></li>
<li>8.4.   <a href="#rfc.section.8.4">Multiplication by Cofactor in Verification</a></li>
<li>8.5.   <a href="#rfc.section.8.5">Related-Key Attacks</a></li>
<li>8.6.   <a href="#rfc.section.8.6">Availability</a></li>
</ul><li>9.   <a href="#rfc.section.9">Discussions</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Hashing the Public Keys in the commitment</a></li>
<li>9.2.   <a href="#rfc.section.9.2">Hashing the bitmask in the commitment</a></li>
<li>9.3.   <a href="#rfc.section.9.3">Exception Mechanism</a></li>
</ul><li>10.   <a href="#rfc.section.10">Acknowledgements</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">A conventional digital signature on some statement S is produced by the holder of a secret key k, and may be verified by anyone against the signer's corresponding public key K. An attacker who successfully steals or compromises the secret key k gains unrestricted ability to impersonate and "sign for" the key-holder. In security-critical contexts it is thus often desirable to divide trust and signing capabilities across several parties. For example, some threshold t out of n known parties may be required to sign a message before verifiers consider it acceptable. A cryptographic proof that multiple parties have cooperated to sign a message is generally known as a multisignature.  </p>
<p id="rfc.section.1.p.2">One form of multisignature is simply a list of individual signatures, which the verifier must check against a given policy. For example, in a 2-of-3 group defined by three public keys, a multisignature is simply a list of two individual signatures, which the verifier must ensure were produced by the holders of any two distinct public keys in the group. Multisignatures of this kind are well-established in many contexts, such as Bitcoin multisignature wallets [BITCOIN], and are practical when the group of signers is small.  </p>
<p id="rfc.section.1.p.3">Another form of multisignatures is based on threshold cryptography that uses mechanisms like Shamir secret sharing [SHAMIR] enabling any threshold t-of-n group members to create a constant-size signature that reveals nothing about which particular set of t members signed. This approach simplifies verification and is desirable when the specific set of cosigners is irrelevant or privacy-sensitive. Secret sharing based multisignatures are inappropriate when transparency is required, though, because t colluding members can potentially sign a bad message but then (individually) deny involvement once the compromise is discovered. Moreover, threshold signature schemes usually do not scale well for larger numbers of n.  </p>
<p id="rfc.section.1.p.4">Collective signatures are compact multisignatures that convey the same information as a list of individual signatures and thereby offer the same transparency, but, at the same time, are comparable in size and verification cost to an individual signature. Group members need not coordinate for the creation of their key-pairs beyond selecting a common elliptic curve, and verifiers can apply flexible acceptance policies beyond simple t-of-n thresholds. Generating collective signatures requires cooperation, but can be done efficiently at with thousands of participants using a tree-aggregation mechanisms as done in the collective signing (CoSi) protocol [COSI].  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#scope" id="scope">Scope</a></h1>
<p id="rfc.section.2.p.1">This document does not attempt to describe CoSi in the context of any particular Internet protocol; instead it describes an abstract protocol that can be easily fitted to a particular application. For example, the specific format of messages is not specified. These issues are left to the protocol implementor to decide.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#notations-and-conventions" id="notations-and-conventions">Notations and Conventions</a></h1>
<p id="rfc.section.3.p.1">The following notation is used throughout the document: </p>
<p/>

<ul>
  <li>p: Prime number.</li>
  <li>GF(p): Finite field with p elements.</li>
  <li>a || b: Concatenation of (bit-)string a with (bit-) string b.</li>
  <li>a + b mod p: Addition of integers a and b modulo prime p.</li>
  <li>a * b mod p: Multiplications of integers a and b modulo prime p.</li>
  <li>B: Generator of the group or subgroup of interest.</li>
  <li>L: Order of the group generated by B.</li>
  <li>I: Neutral element of the group generated by B.</li>
  <li>X + Y: Addition of group elements X and Y.</li>
  <li>[a]X: Addition of X to itself a times (scalar multiplication).</li>
  <li>Aggregation either refers to the addition of two group elements X and Y or to the addition of two scalars a and b.</li>
</ul>

<p> </p>
<p id="rfc.section.3.p.3">CoSi uses the parameters of the elliptic curves Curve25519 and Curve448 defined in Sections 4.1 and 4.2 of [RFC7748], respectively. Encoding and decoding of integers is done as specified in Sections 5.1.2 and 5.1.3 of [RFC8032], respectively.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#collective-signing" id="collective-signing">Collective Signing</a></h1>
<p id="rfc.section.4.p.1">The collective signing (CoSi) algorithm is an aggregate signature scheme based on Schnorr signatures and the EdDSA signing procedure. CoSi signatures are non-deterministic though as they include random participant commitments and a bitmask identifying participants that have not contributed to the signature generation. This section first presents the collective key setup mechanism, the abstract signature generation algorithm and finally the signature verification procedure.  </p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#collective-public-key-setup" id="collective-public-key-setup">Collective Public Key Setup</a></h1>
<p id="rfc.section.4.1.p.1">Let N denote the list of participants. First, each participant i of N generates his longterm private-public key pair (a_i, A_i) as in EdDSA, see Section 5.1.5 of <a href="https://tools.ietf.org/html/rfc8032#page-13">RFC8032</a>. Afterwards, given a list of public keys A_1, ..., A_n, the collective public key is specified as A = A_1 + ... + A_n.  </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#signature-generation" id="signature-generation">Signature Generation</a></h1>
<p id="rfc.section.4.2.p.1">This section presents the collective signature generation scheme.  </p>
<p id="rfc.section.4.2.p.2">The inputs of the signature process are: </p>
<p/>

<ul>
  <li>A collective public key A generated from the public keys of participants N.</li>
  <li>A subset of participants M of N who actively participate in the signature creation. The size of M is denoted by m.</li>
  <li>A statement (or message) S.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.p.4">The signature is generated as follow: </p>
<p/>

<ol>
  <li>For each participant i in M, generate a random secret r_i by hashing 32 bytes of cryptographically secure random data. For efficiency, reduce each r_i mod L.  Each r_i MUST be re-generated until it is different from 0 mod L or 1 mod L.</li>
  <li>Compute the integer addition r of all r<em>i: r = SUM</em>{i in M}(r_i).</li>
  <li>Compute the encoding of the fixed-base scalar multiplication [r]B and call the result R.</li>
  <li>Compute SHA512(R || A || S) and interpret the 64-byte digest as an integer c mod L.</li>
  <li>For each participant i in M, compute the response s_i = (r_i + c * a_i) mod L.</li>
  <li>Compute the integer addition s of all s<em>i: s = SUM</em>{i in M}(s_i).</li>
  <li>Initialize a bitmask Z of length n to all zero. For each participant i who is present in N but not in M set the i-th bit of Z to 1, i.e., Z[i] = 1.</li>
  <li>The signature is the concatenation of the encoded point R, the integer s, and the bitmask Z, denoted as sig = R || s || Z.</li>
</ol>

<p> </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#signature-verification" id="signature-verification">Signature Verification</a></h1>
<p id="rfc.section.4.3.p.1">The inputs to the signature verification process are: </p>
<p/>

<ul>
  <li>A list of public keys A_i of all participants i in N.</li>
  <li>The collective public key A.</li>
  <li>The statement S.</li>
  <li>The signature sig = R || s || Z.</li>
  <li>A signature policy which is a function that takes a bitmask as an input and returns true or false. For example, a basic signature policy might require that a certain threshold of participants took part in the generation of the collective signature.</li>
</ul>

<p> </p>
<p id="rfc.section.4.3.p.3">A signature is considered valid if the verification process finishes each of the steps below successfully.  </p>
<p/>

<ol>
  <li>Split sig into two 32-byte sequences R and s and a bitmask Z. Interpret R as a point on the used elliptic curve and check that it fulfills the curve equation. Interpret s as an unsigned integer and verify that it is non-zero and smaller than L. Verify that Z has length n. If any of the mentioned checks fails, abort the verification process and return false.</li>
  <li>Check Z against the signature policy. If the policy does not hold, abort the verification process and return false.</li>
  <li>Compute SHA512(R || A || S) and interpret the 64-byte digest as an integer c.</li>
  <li>Initialize a new elliptic curve point T = I. For each bit i in the bitmask that is equal to 1, add the corresponding public key A<em>i to the point T.  Formally, T = SUM</em>{i in N, Z[i] == 1}(A_i) for all i set to 1 in the bitmask.</li>
  <li>Compute the reduced public key A' = A - T.</li>
  <li>Check if the group equation [8][s]B = [8]R + [8][c]A' holds.</li>
</ol>

<p> </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#collective-signing-protocol" id="collective-signing-protocol">Collective Signing Protocol</a></h1>
<p id="rfc.section.5.p.1">This section introduces the distributed CoSi protocol with n participants. For simplicity, we assume there is a designated leader who is responsible for collecting the shares and generating the signature. This leader could be any of the signers and is not trusted in any way. All participants are communicating through a reliable channel with the leader.  </p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#collective-signature" id="collective-signature">Collective Signature</a></h1>
<p id="rfc.section.5.1.p.1">The leader must know the statement S to be signed and the set of public keys of the participants N. The point A is defined as the collective key of the participants N. A collective signature is generated in four steps over two round trips between the leader and the rest of the participants.  </p>
<h1 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#announcement" id="announcement">Announcement</a></h1>
<p id="rfc.section.5.1.1.p.1">Upon the request to generate a signature on a statement S, the leader broadcasts an announcement message indicating the start of a signing process. It is up to the implementation to decide whether to send S itself during that phase or not.  </p>
<h1 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#commitment" id="commitment">Commitment</a></h1>
<p id="rfc.section.5.1.2.p.1">Upon the receipt of an announcement message or if the participant is the leader, each participant i generates a random secret r_i by hashing 32 bytes of cryptographically secure random data. Each r_i MUST be re-generated until it is different from 0 mod L or 1 mod L. Each participants then constructs the commitment R_i as the encoding of [r_i]B, sends R_i to the leader and stores the generated r_i for usage in the response phase. If the participant is the leader, it executes the challenge step.  </p>
<h1 id="rfc.section.5.1.3"><a href="#rfc.section.5.1.3">5.1.3.</a> <a href="#challenge" id="challenge">Challenge</a></h1>
<p id="rfc.section.5.1.3.p.1">The leader waits to receive the commitments R_i from the other participants for a certain time frame as defined by the application. After the timeout, the leader constructs the subset M of participants from whom he has received a commitment R<em>i and computes the sum R = SUM</em>{i in M}(R_i). The leader then computes SHA512(R || A || M) and interprets the resulting 64-byte digest as an integer c mod L.  The leader broadcasts c to all participants.  </p>
<h1 id="rfc.section.5.1.4"><a href="#rfc.section.5.1.4">5.1.4.</a> <a href="#response" id="response">Response</a></h1>
<p id="rfc.section.5.1.4.p.1">Upon reception of c or if the participant is the leader, each participant generates his response s_i = (r_i + c * a_i) mod L. Each non-leader participant sends his s_i to the leader. If the participant is the leader, he executes the signature generation step.  </p>
<h1 id="rfc.section.5.1.5"><a href="#rfc.section.5.1.5">5.1.5.</a> <a href="#signature-generation-1" id="signature-generation-1">Signature Generation</a></h1>
<p id="rfc.section.5.1.5.p.1">The leader waits to receive the responses s_i from the other participants for a certain time frame as defined by the application. After the timeout, the leader checks if he received responses from all participants in M and if not he MUST abort the protocol. The leader then computes the aggregate response s = SUM{i in M}(s_i) mod L and initializes a bitmask Z of size n to all zero. For each participant i who is present in N but not in M the leader sets the i-th bit of Z to 1, i.e., Z[i] = 1. The leader then forms the signature sig as the concatenation of the byte-encoded point R, the byte-encoded scalar s, and the bitmask Z. The resulting signature is of the form sig = R || s || Z and MUST be of length 32 + 32 + ceil(n/8) bytes.  </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#collective-verification" id="collective-verification">Collective Verification</a></h1>
<p id="rfc.section.5.2.p.1">The verification process is the same as defined in the Section "Signature Verification" above.  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#treebased-cosi-protocol" id="treebased-cosi-protocol">Tree-based CoSi Protocol</a></h1>
<p id="rfc.section.6.p.1">This section presents the CoSi protocol using a tree-shaped network communication overlay. While the core protocol stays the same, the tree-shaped communication enables CoSi to handle large numbers of participants during signature generation efficiently.  </p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#cosi-tree" id="cosi-tree">CoSi Tree</a></h1>
<p id="rfc.section.6.1.p.1">Any tree used by CoSi SHOULD be a complete tree for performance reasons, i.e., every level except possible the last one of the tree MUST be filled. The leader is the root node of the tree and is responsible for creating the tree. An intermediate node is a node who has one parent node and at least one child node.  A leaf node is a node who has only one parent and no child nodes.  </p>
<p id="rfc.section.6.1.p.2">We define the BROADCAST operation as: </p>
<p/>

<ul>
  <li>The leader multicasts a message to his direct child nodes.</li>
  <li>Upon reception of a message, each node stores the message and multicasts it further down to its children node, except if the node is a leaf.</li>
</ul>

<p> </p>
<p id="rfc.section.6.1.p.4">The internal representation of the tree, and its propagation to the participants is left to the application.  </p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#collective-signature-1" id="collective-signature-1">Collective Signature</a></h1>
<p id="rfc.section.6.2.p.1">The leader must know the statement S, the set N of the participants and their public keys, and the subset M of active participants. The actual communication tree T is created from the subset M, and MUST contain all participants of M. The point A is defined as the collective key of the set P.  </p>
<h1 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#announcement-1" id="announcement-1">Announcement</a></h1>
<p id="rfc.section.6.2.1.p.1">The leader BROADCASTS an announcement message. Upon reception, each leaf node executes the commitment step.  </p>
<h1 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#commitment-1" id="commitment-1">Commitment</a></h1>
<p id="rfc.section.6.2.2.p.1">Every node must generate a random commitment R_i as described in the previous commitment section [...]. Each leaf node directly sends its commitment R_i to its parent node.  Each non-leaf node generates a bit mask Z_i of n bits initialized with all 0 bits and starts waiting for a commitment and a bit mask from each of its children. After the timeout defined by the application, each node aggregates all its children's commitments R_i received using point addition formulas, adds its own commitment and stores the result in R'. For every absent commitment from a child at index j in N, the node sets the j-th of its bit mask Z_i to 1. The node also performs an OR operation between all the received bitmasks from its children and its own bit mask, and let the result be B'.  <br/> // XXX Should we reject invalid messages, like too-long-bitmask or so? // XXX Bitmasks should be signed and checked? If the node is an intermediate node, it sends the aggregated commitment R' alongside with the Z' bitmask to its parents. If the node is the root node, it executes the challenge step.  </p>
<p id="rfc.section.6.2.2.p.2">// XXX What happens when a node does not receive any commitment from a child node. Does it contact the sub-nodes? </p>
<h1 id="rfc.section.6.2.3"><a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#challenge-1" id="challenge-1">Challenge</a></h1>
<p id="rfc.section.6.2.3.p.1">The leader computes the challenge c = H( R' || A || S) and BROADCASTS it down the tree. The leader also saves the bitmask Z' computed in the previous step. Upon reception, each leaf node executes the response step.  </p>
<h1 id="rfc.section.6.2.4"><a href="#rfc.section.6.2.4">6.2.4.</a> <a href="#response-1" id="response-1">Response</a></h1>
<p id="rfc.section.6.2.4.p.1">Each node generates its response s_i as defined in XXX Response XXX. Each leaf node sends its response to their parent and is allowed to leave the protocol.  <br/> Each other node starts waiting for the responses of its children.  </p>
<p id="rfc.section.6.2.4.p.2">XXX HOW to signal / abort? Is it application dependent also? What happens if the root times out? </p>
<p id="rfc.section.6.2.4.p.3">For each response s received in node i from node's children j, the node i SHOULD perform a verification of the partial response. Let t be the sub-tree with the node j at the root, and D  the aggregation of all the public keys of the participants in t. Let V be the aggregation of all commitments generated by all participants in t. If the equation [8][s]B = [8]V + [8][c]D does not hold, then the node i MUST abort the protocol.  </p>
<p id="rfc.section.6.2.4.p.4">After the timeout occurs, if at least one child's response is missing, the node MUST signal the leader to abort the protocol. Otherwise, each intermediate node aggregates all its children's responses, adds its own response s_i, using scalar addition formulas and sends the resulting scalar s' up to its parent. Each intermediate node can now leave the protocol.  </p>
<p id="rfc.section.6.2.4.p.5">When the root node receives all the responses s' from its children, it can generate the signature.  </p>
<h1 id="rfc.section.6.2.5"><a href="#rfc.section.6.2.5">6.2.5.</a> <a href="#signature-generation-2" id="signature-generation-2">Signature Generation</a></h1>
<p id="rfc.section.6.2.5.p.1">The generation procedure is exactly the same as in the XXX Generation XXX section above.  </p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#verification" id="verification">Verification</a></h1>
<p id="rfc.section.6.3.p.1">The verification procedure is exactly the same as in the XXX Verify XXX section above.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#message-format" id="message-format">Message Format</a></h1>
<p id="rfc.section.7.p.1">All packets exchanged during a CoSi protocol's instance MUST be encoded using Google's Protobuf technology [PROTOBUF].  All packets for a CoSi protocol must be encoded inside the CoSiPacket message format. The <samp>phase</samp> field indicates which message is encoded in the packet.  The CoSi packet message contains a <samp>phase</samp> field which is set accordingly to the current phase of the protocol: + Announcement = 1 + Commitment = 2 + Challenge = 3 + Response = 4 </p>
<pre>
message CoSiPacket {
  // Announcement = 1, Commitment = 2, Challenge = 3, Response = 4
  required uint32 phase = 1;
  optional Announcement ann = 2;
  optional Commitment comm = 3;
  optional Challenge chal = 4;
  optional Response resp = 5;
}
</pre>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#announcement-2" id="announcement-2">Announcement</a></h1>
<p id="rfc.section.7.1.p.1">The Announcement message notifies participants of the beginning of a CoSi round. Implementations can extent the message specifications to include the message to sign. That way, participants can refuse to vote at this step by not replying with a commitment. This do not cause any restart of the protocol later.  </p>
<pre>
message Announcement {
}
</pre>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#commitment-2" id="commitment-2">Commitment</a></h1>
<p id="rfc.section.7.2.p.1">The commitment message includes the aggregated commitment as well as the bitmask if the tree based CoSi protocol is used.  </p>
<pre>
message Commitment {
  // aggregated commitment R'
  required bytes comm = 1;
  // bitmask B'
  optional bytes mask = 2;
}
</pre>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#challenge-2" id="challenge-2">Challenge</a></h1>
<p id="rfc.section.7.3.p.1">The challenge message includes the challenge computed by the leader of the CoSi protocol.  </p>
<pre>
message Challenge {
  // commputed challenge c
  required bytes chall = 1;
}
</pre>
<h1 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> <a href="#response-2" id="response-2">Response</a></h1>
<p id="rfc.section.7.4.p.1">The response message includes the aggregated response to be sent to the leader.  </p>
<pre>
message Response {
  // aggregated response s'
  required bytes resp = 1;
}
</pre>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<h1 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#general-implementations-checks" id="general-implementations-checks">General Implementations Checks</a></h1>
<p id="rfc.section.8.1.p.1">The checks described throughout the different protocols MUST be enforced. Namely that includes: + the random component r MUST conform to r != 0 mod L and r != 1 mod L.  + the resulting signature s MUST conform to  s != 0 mod L during signature generation + the signature s MUST conform to 0 &lt; s &lt; L + the intermediate signature at each level of the tree MUST be verifiable correctly as described in section the Response step in section XXX </p>
<h1 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#random-number-generation" id="random-number-generation">Random Number Generation</a></h1>
<p id="rfc.section.8.2.p.1">CoSi requires a cryptographically secure pseudorandom number generator (PRNG) for the generation of the private key and the seed to get the random integer r.  In most cases, the operating system provides an appropriate facility such as /dev/urandom, which should be used absent other (performance) concerns.  It is generally preferable to use an existing PRNG implementation in preference to crafting a new one, and many adequate cryptographic libraries are already available under favorable license terms.  Should those prove unsatisfactory, [RFC4086] provides guidance on the generation of random values. The hashing of the seed provides an additional layer of security regardless of the security of the PRNG.  </p>
<h1 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a> <a href="#group-membership" id="group-membership">Group Membership</a></h1>
<p id="rfc.section.8.3.p.1">Elements should be checked for group membership: failure to properly validate group elements can lead to attacks. In particular it is essential to verify that received points are valid compressions of points on an elliptic curve when using elliptic curves.  </p>
<h1 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a> <a href="#multiplication-by-cofactor-in-verification" id="multiplication-by-cofactor-in-verification">Multiplication by Cofactor in Verification</a></h1>
<p id="rfc.section.8.4.p.1">The given verification formulas multiply points by the cofactor.  While this is not strictly necessary for security (in fact, any signature that meets the non-multiplied equation will satisfy the multiplied one), in some applications it is undesirable for implementations to disagree about the exact set of valid signatures.  </p>
<h1 id="rfc.section.8.5"><a href="#rfc.section.8.5">8.5.</a> <a href="#relatedkey-attacks" id="relatedkey-attacks">Related-Key Attacks</a></h1>
<p id="rfc.section.8.5.p.1">Before any CoSi round happens, all the participants MUST have the list of public keys of the whole set of participants, including a self signature for each public key. This list MUST be generated before any round. If it it not the case, an attacker can craft a special public key which has the effect of eliminating the contribution of a specific participant to the signature.  </p>
<h1 id="rfc.section.8.6"><a href="#rfc.section.8.6">8.6.</a> <a href="#availability" id="availability">Availability</a></h1>
<p id="rfc.section.8.6.p.1">The participating servers should be highly available and should be operated by reputable and competent organizations so the risk a of DDOS attack by un-reliable participants is greatly diminished. In case of failures before the Challenge phase, the leader might abort the protocol if the threshold of present participants is too low.  </p>
<p id="rfc.section.8.6.p.2">If a participant detects one of its children in the tree as missing, a simple mechanism is to return an error which propagates back up the tree to the leader.  The leader can then restart the round accounting for this missing participant in the bitmask B described in the Commitment section XXX.  </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#discussions" id="discussions">Discussions</a></h1>
<h1 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#hashing-the-public-keys-in-the-commitment" id="hashing-the-public-keys-in-the-commitment">Hashing the Public Keys in the commitment</a></h1>
<p id="rfc.section.9.1.p.1">Either do H(R || A || msg) with A being the collective public key OR do H(R || SUM(X_i) || msg) where SUM(X_i) is the sum of all public keys that participated in the collective signature,i.e. the aggregation of all keys in the active participant subset Q.  </p>
<h1 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> <a href="#hashing-the-bitmask-in-the-commitment" id="hashing-the-bitmask-in-the-commitment">Hashing the bitmask in the commitment</a></h1>
<p id="rfc.section.9.2.p.1">To truely bind one signature to a set of signers, the bitmask can be included in the challenge computation such like H(R || A || bitmask || msg). The signature verification process could detect any modifications of the original signature before proceeding the computationally expensive process.  </p>
<h1 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3.</a> <a href="#exception-mechanism" id="exception-mechanism">Exception Mechanism</a></h1>
<p id="rfc.section.9.3.p.1">XXX What to do in case a node goes offline, doesn't sign, or doesn't relay up etc. in the tree approach.  </p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.10.p.1">Many parts of this document were inspired by RFC8032 on EdDSA.  </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Bryan Ford</span> 
	  <span class="n hidden">
		<span class="family-name">Ford</span>
	  </span>
	</span>
	<span class="org vcardline">EPFL</span>
	<span class="adr">
	  <span class="vcardline">BC 210, Station 14</span>

	  <span class="vcardline">
		<span class="locality">Lausanne</span>,  
		<span class="region"></span>
		<span class="code">CH-1015</span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">Phone: +41 21 693 28 73</span>

<span class="vcardline">EMail: <a href="mailto:bryan.ford@epfl.ch">bryan.ford@epfl.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nicolas Gailly</span> 
	  <span class="n hidden">
		<span class="family-name">Gailly</span>
	  </span>
	</span>
	<span class="org vcardline">EPFL</span>
	<span class="adr">
	  <span class="vcardline">BC 263, Station 14</span>

	  <span class="vcardline">
		<span class="locality">Lausanne</span>,  
		<span class="region"></span>
		<span class="code">CH-1015</span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">Phone: +41 21 69 36613</span>

<span class="vcardline">EMail: <a href="mailto:nicolas.gailly@epfl.ch">nicolas.gailly@epfl.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Linus Gasser</span> 
	  <span class="n hidden">
		<span class="family-name">Gasser</span>
	  </span>
	</span>
	<span class="org vcardline">EPFL</span>
	<span class="adr">
	  <span class="vcardline">BC 208, Station 14</span>

	  <span class="vcardline">
		<span class="locality">Lausanne</span>,  
		<span class="region"></span>
		<span class="code">CH-1015</span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">Phone: +41 21 69 36770</span>

<span class="vcardline">EMail: <a href="mailto:linus.gasser@epfl.ch">linus.gasser@epfl.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philipp Jovanovic</span> 
	  <span class="n hidden">
		<span class="family-name">Jovanovic</span>
	  </span>
	</span>
	<span class="org vcardline">EPFL</span>
	<span class="adr">
	  <span class="vcardline">BC 263, Station 14</span>

	  <span class="vcardline">
		<span class="locality">Lausanne</span>,  
		<span class="region"></span>
		<span class="code">CH-1015</span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">Phone: +41 21 69 36628</span>

<span class="vcardline">EMail: <a href="mailto:philipp.jovanovic@epfl.ch">philipp.jovanovic@epfl.ch</a></span>

  </address>
</div>

</body>
</html>
